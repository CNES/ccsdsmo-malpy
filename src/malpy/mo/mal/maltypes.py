# SPDX-FileCopyrightText: 2025 Olivier Churlaud <olivier@churlaud.com>
# SPDX-FileCopyrightText: 2025 CNES
#
# SPDX-License-Identifier: MIT

#####################################################
# Generated by generators/generator.py              #
# This file is generated. Do NOT edit it by hand.   #
#####################################################

"""None"""

from enum import IntEnum
from abc import ABC

name = "MAL"
number = 1
version = 3

class MALShortForm(IntEnum):
    BLOB = 1
    BOOLEAN = 2
    DURATION = 3
    FLOAT = 4
    DOUBLE = 5
    IDENTIFIER = 6
    OCTET = 7
    UOCTET = 8
    SHORT = 9
    USHORT = 10
    INTEGER = 11
    UINTEGER = 12
    LONG = 13
    ULONG = 14
    STRING = 15
    TIME = 16
    FINETIME = 17
    URI = 18
    OBJECTREF = 19
    INTERACTIONTYPE = 101
    SESSIONTYPE = 102
    QOSLEVEL = 103
    ATTRIBUTETYPE = 104
    MOAREA = 105
    SUBSCRIPTION = 1001
    SUBSCRIPTIONFILTER = 1002
    UPDATEHEADER = 1003
    IDBOOLEANPAIR = 1004
    PAIR = 1005
    NAMEDVALUE = 1006
    FILE = 1007
    OBJECTIDENTITY = 1008
    SERVICEID = 1009
    NULLABLEATTRIBUTE = 1010


class Element(ABC):
    """Element is the base type of all data constructs. All types that make up the MAL data model are derived from it."""

    shortForm = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        self._isNull = False
        self._canBeNull = canBeNull
        self.attribName = attribName
        if value is None and not self._canBeNull:
            raise ValueError('This {} cannot be None.'.format(type(self).__name__))

    @property
    def internal_value(self):
        if self._isNull:
            return None
        else:
            return self._internal_value


class ElementList(Element):
    shortForm = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)

    @property
    def internal_value(self):
       return self._internal_value

    def copy(self):
        if self._isNull:
            value = None
        else:
            value = []
            for v in self.internal_value:
                value.append(v.copy())
        return self.__class__(value)


class Attribute(Element):
    """Attribute is the base type of all Attributes of the MAL data model. Attributes are contained within Composites and are used to build complex structures that make the data model."""

    shortForm = None

    value_type = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            self._internal_value = value.copy().internal_value
        elif type(value) == type(self).value_type:
            self._internal_value = value
        elif type(self) == type(Attribute(None)) and value.shortForm in range(1,19):
            self._internal_value = value.copy().internal_value
            self.shortForm = value.shortForm
            self.value_type = value.value_type
        else:
            raise TypeError("Expected {}, got {}.".format(type(self).value_type, type(value)))

    def copy(self):
        return self.__class__(self.internal_value, self._canBeNull)


class AttributeList(ElementList):
    shortForm = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Attribute(v))


class AbstractEnum(Attribute):

    value_type = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        if type(value) == type(''):
            for v in list(self.value_type):
                 if v.name == value:
                     value = v
        elif type(value) == type(1):
            value = self.value_type(value)
        elif type(value) == type(self).value_type:
            pass  # Everything is fine
        elif type(value) == type(self):
            value = value.internal_value
        else:
            raise TypeError("Expected {}, got {}.".format(type(self).value_type, type(value)))
        super().__init__(value, canBeNull, attribName)


class Composite(Element):
    """Composite is the base structure for Composite structures that contain a set of Elements."""

    shortForm = None

    _fieldNumber = 0

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []

    def copy(self):
        if self._isNull:
            value = None
        else:
            value = []
            for v in self.internal_value:
                value.append(v.copy())
        return self.__class__(value, self._canBeNull)


class CompositeList(ElementList):
    shortForm = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Composite(v))


class Object(Composite):
    """Object is the base structure for MO Objects in the MAL data model. Objects are representations of complex data types with two specific characteristics: Objects have a unique and an immutable identity and can be referenced unambiguously."""

    shortForm = None


class ObjectList(ElementList):
    shortForm = None

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Object(v))


class Blob(Attribute):
    """The Blob structure shall be used to hold binary data. It shall be a variable-length Octet array and the maximum length shall depend on the selected encoding."""

    shortForm = MALShortForm.BLOB
    value_type = bytes


class BlobList(ElementList):
    shortForm = -MALShortForm.BLOB

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Blob(v))


class Boolean(Attribute):
    """The Boolean structure shall be used to hold Boolean Attributes. Possible values are ‘True’ or ‘False’."""

    shortForm = MALShortForm.BOOLEAN
    value_type = bool


class BooleanList(ElementList):
    shortForm = -MALShortForm.BOOLEAN

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Boolean(v))


class Duration(Attribute):
    """The Duration structure shall be used to hold duration Attributes at nanoseconds resolution. It can be negative because it may be used to represent offsets. The duration shall support a range between -2^63 nanoseconds, and (2^63)-1 nanoseconds (to allow representation as a 64-bit signed integer)."""

    shortForm = MALShortForm.DURATION
    value_type = float


class DurationList(ElementList):
    shortForm = -MALShortForm.DURATION

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Duration(v))


class Float(Attribute):
    """The Float structure shall be used to hold floating point Attributes using the IEEE 754 32-bit range."""

    shortForm = MALShortForm.FLOAT
    value_type = float


class FloatList(ElementList):
    shortForm = -MALShortForm.FLOAT

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Float(v))


class Double(Attribute):
    """The Double structure shall be used to hold floating point Attributes using the IEEE 754 64-bit range."""

    shortForm = MALShortForm.DOUBLE
    value_type = float


class DoubleList(ElementList):
    shortForm = -MALShortForm.DOUBLE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Double(v))


class Identifier(Attribute):
    """The Identifier structure shall be used to hold an identifier and can be used for indexing. It is a variable-length Unicode string and the maximum length shall depend on the selected encoding. For some encoding/decoding bindings, the use of a numeric value might be appropriate for this Attribute, for example, via a dictionary."""

    shortForm = MALShortForm.IDENTIFIER
    value_type = str


class IdentifierList(ElementList):
    shortForm = -MALShortForm.IDENTIFIER

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Identifier(v))


class Octet(Attribute):
    """The Octet structure shall be used to hold 8-bit signed Attributes. The permitted range is −128 to 127."""

    shortForm = MALShortForm.OCTET
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < -128 or value > 127 ):
            raise ValueError("Authorized value is between -128 and 127.")


class OctetList(ElementList):
    shortForm = -MALShortForm.OCTET

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Octet(v))


class UOctet(Attribute):
    """The UOctet structure shall be used to hold 8-bit unsigned Attributes. The permitted range is 0 to 255."""

    shortForm = MALShortForm.UOCTET
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < 0 or value > 255 ):
            raise ValueError("Authorized value is between 0 and 255.")


class UOctetList(ElementList):
    shortForm = -MALShortForm.UOCTET

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(UOctet(v))


class Short(Attribute):
    """The Short structure shall be used to hold 16-bit signed Attributes. The permitted range is −32768 to 32767."""

    shortForm = MALShortForm.SHORT
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < -32768 or value > 32767 ):
            raise ValueError("Authorized value is between -32768 and 32767.")


class ShortList(ElementList):
    shortForm = -MALShortForm.SHORT

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Short(v))


class UShort(Attribute):
    """The UShort structure shall be used to hold 16-bit unsigned Attributes. The permitted range is 0 to 65535."""

    shortForm = MALShortForm.USHORT
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < 0 or value > 65535 ):
            raise ValueError("Authorized value is between 0 and 65535.")


class UShortList(ElementList):
    shortForm = -MALShortForm.USHORT

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(UShort(v))


class Integer(Attribute):
    """The Integer structure shall be used to hold 32-bit signed Attributes. The permitted range is −2147483648 to 2147483647."""

    shortForm = MALShortForm.INTEGER
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < -2147483648 or value > 21474836487 ):
            raise ValueError("Authorized value is between -2147483648 and 21474836487.")


class IntegerList(ElementList):
    shortForm = -MALShortForm.INTEGER

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Integer(v))


class UInteger(Attribute):
    """The UInteger structure shall be used to hold 32-bit unsigned Attributes. The permitted range is 0 to 4294967295."""

    shortForm = MALShortForm.UINTEGER
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < 0 or value > 4294967295 ):
            raise ValueError("Authorized value is between 0 and 4294967295.")


class UIntegerList(ElementList):
    shortForm = -MALShortForm.UINTEGER

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(UInteger(v))


class Long(Attribute):
    """The Long structure shall be used to hold 64-bit signed Attributes. The permitted range is −9223372036854775808 to 9223372036854775807."""

    shortForm = MALShortForm.LONG
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < -9223372036854775808 or value > 9223372036854775807 ):
            raise ValueError("Authorized value is between -9223372036854775808 and 9223372036854775807.")


class LongList(ElementList):
    shortForm = -MALShortForm.LONG

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Long(v))


class ULong(Attribute):
    """The ULong structure shall be used to hold 64-bit unsigned Attributes. The permitted range is 0 to 18446744073709551615."""

    shortForm = MALShortForm.ULONG
    value_type = int

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        if type(value) == int and ( value < 0 or value > 18446744073709551615 ):
            raise ValueError("Authorized value is between 0 and 18446744073709551615.")


class ULongList(ElementList):
    shortForm = -MALShortForm.ULONG

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(ULong(v))


class String(Attribute):
    """The String structure shall be used to hold string Attributes. It is a variable-length Unicode string and the maximum length shall depend on the selected encoding."""

    shortForm = MALShortForm.STRING
    value_type = str


class StringList(ElementList):
    shortForm = -MALShortForm.STRING

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(String(v))


class Time(Attribute):
    """The Time structure shall be used to hold absolute time Attributes. It shall represent an absolute date and time to millisecond resolution. The range shall depend on the selected encoding."""

    shortForm = MALShortForm.TIME
    value_type = float


class TimeList(ElementList):
    shortForm = -MALShortForm.TIME

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Time(v))


class FineTime(Attribute):
    """The FineTime structure shall be used to hold high-resolution absolute time Attributes. It shall represent an absolute date and time to nanosecond resolution. The range shall depend on the selected encoding."""

    shortForm = MALShortForm.FINETIME
    value_type = float


class FineTimeList(ElementList):
    shortForm = -MALShortForm.FINETIME

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(FineTime(v))


class URI(Attribute):
    """The URI structure shall be used to hold URI addresses. It shall be a variable-length Unicode string and the maximum length shall depend on the selected encoding."""

    shortForm = MALShortForm.URI
    value_type = str


class URIList(ElementList):
    shortForm = -MALShortForm.URI

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(URI(v))


class ObjectRef(Attribute):
    """The ObjectRef structure shall be used to hold references to MO Objects."""

    shortForm = MALShortForm.OBJECTREF

    def __init__(self, value=None, canBeNull=True, attribName=None):
        Element.__init__(self, value, canBeNull, attribName)
        self._internal_value = [None]*4
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.domain = value[0]
            self.type = value[1]
            self.key = value[2]
            self.version = value[3]

    @property
    def domain(self):
        return self._internal_value[0]

    @domain.setter
    def domain(self, domain):
        self._internal_value[0] = IdentifierList(domain, canBeNull=False, attribName='domain')
        self._isNull = False

    @property
    def type(self):
        return self._internal_value[1]

    @type.setter
    def type(self, objecType):
        self._internal_value[1] = Long(objecType, canBeNull=False, attribName='type')
        self._isNull = False

    @property
    def key(self):
        return self._internal_value[2]

    @key.setter
    def key(self, key):
        self._internal_value[2] = Identifier(key, canBeNull=True, attribName='key')  # TODO: change to False when ESA impl is fixed
        self._isNull = False

    @property
    def version(self):
        return self._internal_value[3]

    @version.setter
    def version(self, version):
        self._internal_value[3] = UInteger(version, canBeNull=False, attribName='version')
        self._isNull = False


class ObjectRefList(ElementList):
    shortForm = -MALShortForm.OBJECTREF

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(ObjectRef(v))


class InteractionTypeEnum(IntEnum):
    """InteractionType is an enumeration that shall be used to hold the possible Interaction Pattern types."""

    SEND = 1  # Used for SEND interactions.
    SUBMIT = 2  # Used for SUBMIT interactions.
    REQUEST = 3  # Used for REQUEST interactions.
    INVOKE = 4  # Used for INVOKE interactions.
    PROGRESS = 5  # Used for PROGRESS interactions.
    PUBSUB = 6  # Used for Publish-Subscribe interactions.


class InteractionType(AbstractEnum):
    """InteractionType is an enumeration that shall be used to hold the possible Interaction Pattern types."""

    shortForm = MALShortForm.INTERACTIONTYPE
    value_type = InteractionTypeEnum


class InteractionTypeList(ElementList):
    shortForm = -MALShortForm.INTERACTIONTYPE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(InteractionType(v))


class SessionTypeEnum(IntEnum):
    """SessionType is an enumeration that shall be used to hold the session types. This facilitates the use of different Sessions in out-of-band agreements."""

    LIVE = 1  # Used for Live sessions.
    SIMULATION = 2  # Used for Simulation sessions.
    REPLAY = 3  # Used for Replay sessions.


class SessionType(AbstractEnum):
    """SessionType is an enumeration that shall be used to hold the session types. This facilitates the use of different Sessions in out-of-band agreements."""

    shortForm = MALShortForm.SESSIONTYPE
    value_type = SessionTypeEnum


class SessionTypeList(ElementList):
    shortForm = -MALShortForm.SESSIONTYPE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(SessionType(v))


class QoSLevelEnum(IntEnum):
    """QoSLevel is an enumeration that shall be used to hold the possible QoS levels. This facilitates the use of different QoS in out-of-band agreements."""

    BESTEFFORT = 1  # Used for Best Effort QoS Level.
    ASSURED = 2  # Used for Assured QoS Level.
    QUEUED = 3  # Used for Queued QoS Level.
    TIMELY = 4  # Used for Timely QoS Level.


class QoSLevel(AbstractEnum):
    """QoSLevel is an enumeration that shall be used to hold the possible QoS levels. This facilitates the use of different QoS in out-of-band agreements."""

    shortForm = MALShortForm.QOSLEVEL
    value_type = QoSLevelEnum


class QoSLevelList(ElementList):
    shortForm = -MALShortForm.QOSLEVEL

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(QoSLevel(v))


class AttributeTypeEnum(IntEnum):
    """AttributeType is an enumeration that shall be used to hold the defined MAL Attribute types."""

    BLOB = 1  # Blob type.
    BOOLEAN = 2  # Boolean type.
    DURATION = 3  # Duration type.
    FLOAT = 4  # Float type.
    DOUBLE = 5  # Double type.
    IDENTIFIER = 6  # Identifier type.
    OCTET = 7  # Octet type.
    UOCTET = 8  # UOctet type.
    SHORT = 9  # Short type.
    USHORT = 10  # UShort type.
    INTEGER = 11  # Integer type.
    UINTEGER = 12  # UInteger type.
    LONG = 13  # Long type.
    ULONG = 14  # ULong type.
    STRING = 15  # String type.
    TIME = 16  # Time type.
    FINETIME = 17  # FineTime type.
    URI = 18  # URI type.
    OBJECTREF = 19  # ObjectRef type.


class AttributeType(AbstractEnum):
    """AttributeType is an enumeration that shall be used to hold the defined MAL Attribute types."""

    shortForm = MALShortForm.ATTRIBUTETYPE
    value_type = AttributeTypeEnum


class AttributeTypeList(ElementList):
    shortForm = -MALShortForm.ATTRIBUTETYPE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(AttributeType(v))


class MOAreaEnum(IntEnum):
    """MOArea is an enumeration that shall be used to hold the known existing area numbers in use."""

    MAL = 1  # The MAL area number.
    COM = 2  # The COM area number. The COM is deprecated; therefore this area number is reserved for backward compatibility.
    COMMON = 3  # The Common area number.
    MC = 4  # The Monitor and Control area number.
    MPS = 5  # The Mission Planning and Scheduling area number.
    SM = 7  # The Software Management area number.
    MDPD = 9  # The Mission Data Product Distribution area number.


class MOArea(AbstractEnum):
    """MOArea is an enumeration that shall be used to hold the known existing area numbers in use."""

    shortForm = MALShortForm.MOAREA
    value_type = MOAreaEnum


class MOAreaList(ElementList):
    shortForm = -MALShortForm.MOAREA

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(MOArea(v))


class Subscription(Composite):
    """The Subscription structure shall be used when subscribing for updates using the PUBSUB Interaction Pattern. It shall contain a single identifier that identifies the subscription being defined and a set of entities being requested."""

    shortForm = MALShortForm.SUBSCRIPTION
    _fieldNumber = Composite._fieldNumber + 4

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*4
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.subscriptionId = value[Composite._fieldNumber + 0]
            self.domain = value[Composite._fieldNumber + 1]
            self.selectedKeys = value[Composite._fieldNumber + 2]
            self.filters = value[Composite._fieldNumber + 3]

    @property
    def subscriptionId(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @subscriptionId.setter
    def subscriptionId(self, subscriptionId):
        self._internal_value[Composite._fieldNumber + 0] = Identifier(subscriptionId, canBeNull=False, attribName='subscriptionId')
        self._isNull = False

    @property
    def domain(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @domain.setter
    def domain(self, domain):
        self._internal_value[Composite._fieldNumber + 1] = IdentifierList(domain, canBeNull=True, attribName='domain')
        self._isNull = False

    @property
    def selectedKeys(self):
        return self._internal_value[Composite._fieldNumber + 2]

    @selectedKeys.setter
    def selectedKeys(self, selectedKeys):
        self._internal_value[Composite._fieldNumber + 2] = IdentifierList(selectedKeys, canBeNull=True, attribName='selectedKeys')
        self._isNull = False

    @property
    def filters(self):
        return self._internal_value[Composite._fieldNumber + 3]

    @filters.setter
    def filters(self, filters):
        self._internal_value[Composite._fieldNumber + 3] = SubscriptionFilterList(filters, canBeNull=True, attribName='filters')
        self._isNull = False


class SubscriptionList(ElementList):
    shortForm = -MALShortForm.SUBSCRIPTION

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Subscription(v))


class SubscriptionFilter(Composite):
    """The SubscriptionFilter structure shall be used when subscribing for updates using the PUBSUB Interaction Pattern. It shall contain a single identifier that identifies the Subscription Key name and the set of values to be registered for the defined key name."""

    shortForm = MALShortForm.SUBSCRIPTIONFILTER
    _fieldNumber = Composite._fieldNumber + 2

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*2
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.name = value[Composite._fieldNumber + 0]
            self.values = value[Composite._fieldNumber + 1]

    @property
    def name(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @name.setter
    def name(self, name):
        self._internal_value[Composite._fieldNumber + 0] = Identifier(name, canBeNull=False, attribName='name')
        self._isNull = False

    @property
    def values(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @values.setter
    def values(self, values):
        self._internal_value[Composite._fieldNumber + 1] = AttributeList(values, canBeNull=False, attribName='values')
        self._isNull = False


class SubscriptionFilterList(ElementList):
    shortForm = -MALShortForm.SUBSCRIPTIONFILTER

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(SubscriptionFilter(v))


class UpdateHeader(Composite):
    """The UpdateHeader structure shall be used by updates using the PUBSUB Interaction Pattern. It shall hold information that identifies a single update."""

    shortForm = MALShortForm.UPDATEHEADER
    _fieldNumber = Composite._fieldNumber + 3

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*3
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.source = value[Composite._fieldNumber + 0]
            self.domain = value[Composite._fieldNumber + 1]
            self.keyValues = value[Composite._fieldNumber + 2]

    @property
    def source(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @source.setter
    def source(self, source):
        self._internal_value[Composite._fieldNumber + 0] = Identifier(source, canBeNull=True, attribName='source')
        self._isNull = False

    @property
    def domain(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @domain.setter
    def domain(self, domain):
        self._internal_value[Composite._fieldNumber + 1] = IdentifierList(domain, canBeNull=True, attribName='domain')
        self._isNull = False

    @property
    def keyValues(self):
        return self._internal_value[Composite._fieldNumber + 2]

    @keyValues.setter
    def keyValues(self, keyValues):
        self._internal_value[Composite._fieldNumber + 2] = NullableAttributeList(keyValues, canBeNull=True, attribName='keyValues')
        self._isNull = False


class UpdateHeaderList(ElementList):
    shortForm = -MALShortForm.UPDATEHEADER

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(UpdateHeader(v))


class IdBooleanPair(Composite):
    """IdBooleanPair shall be a simple pair type of an identifier and Boolean value."""

    shortForm = MALShortForm.IDBOOLEANPAIR
    _fieldNumber = Composite._fieldNumber + 2

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*2
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.id = value[Composite._fieldNumber + 0]
            self.value = value[Composite._fieldNumber + 1]

    @property
    def id(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @id.setter
    def id(self, id):
        self._internal_value[Composite._fieldNumber + 0] = Identifier(id, canBeNull=False, attribName='id')
        self._isNull = False

    @property
    def value(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @value.setter
    def value(self, value):
        self._internal_value[Composite._fieldNumber + 1] = Boolean(value, canBeNull=True, attribName='value')
        self._isNull = False


class IdBooleanPairList(ElementList):
    shortForm = -MALShortForm.IDBOOLEANPAIR

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(IdBooleanPair(v))


class Pair(Composite):
    """Pair shall be a simple Composite structure for holding pairs."""

    shortForm = MALShortForm.PAIR
    _fieldNumber = Composite._fieldNumber + 2

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*2
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.first = value[Composite._fieldNumber + 0]
            self.second = value[Composite._fieldNumber + 1]

    @property
    def first(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @first.setter
    def first(self, first):
        if first is None:
            self._internal_value[Composite._fieldNumber + 0] = Attribute(first, canBeNull=True, attribName='first')
        else:
            self._internal_value[Composite._fieldNumber + 0] = type(first)(first, canBeNull=True, attribName='first')
        self._isNull = False

    @property
    def second(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @second.setter
    def second(self, second):
        if second is None:
            self._internal_value[Composite._fieldNumber + 1] = Attribute(second, canBeNull=True, attribName='second')
        else:
            self._internal_value[Composite._fieldNumber + 1] = type(second)(second, canBeNull=True, attribName='second')
        self._isNull = False


class PairList(ElementList):
    shortForm = -MALShortForm.PAIR

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(Pair(v))


class NamedValue(Composite):
    """The NamedValue structure shall represent a simple pair type of an identifier and abstract Attribute value."""

    shortForm = MALShortForm.NAMEDVALUE
    _fieldNumber = Composite._fieldNumber + 2

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*2
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.name = value[Composite._fieldNumber + 0]
            self.value = value[Composite._fieldNumber + 1]

    @property
    def name(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @name.setter
    def name(self, name):
        self._internal_value[Composite._fieldNumber + 0] = Identifier(name, canBeNull=False, attribName='name')
        self._isNull = False

    @property
    def value(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @value.setter
    def value(self, value):
        if value is None:
            self._internal_value[Composite._fieldNumber + 1] = Attribute(value, canBeNull=True, attribName='value')
        else:
            self._internal_value[Composite._fieldNumber + 1] = type(value)(value, canBeNull=True, attribName='value')
        self._isNull = False


class NamedValueList(ElementList):
    shortForm = -MALShortForm.NAMEDVALUE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(NamedValue(v))


class File(Composite):
    """The File structure represents a file and shall be used to hold details about a file. It may also, optionally, hold a BLOB of the file data. The file type shall be denoted using the internet MIME media types."""

    shortForm = MALShortForm.FILE
    _fieldNumber = Composite._fieldNumber + 7

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*7
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.name = value[Composite._fieldNumber + 0]
            self.mimeType = value[Composite._fieldNumber + 1]
            self.creationDate = value[Composite._fieldNumber + 2]
            self.modificationDate = value[Composite._fieldNumber + 3]
            self.size = value[Composite._fieldNumber + 4]
            self.content = value[Composite._fieldNumber + 5]
            self.metaData = value[Composite._fieldNumber + 6]

    @property
    def name(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @name.setter
    def name(self, name):
        self._internal_value[Composite._fieldNumber + 0] = String(name, canBeNull=False, attribName='name')
        self._isNull = False

    @property
    def mimeType(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @mimeType.setter
    def mimeType(self, mimeType):
        self._internal_value[Composite._fieldNumber + 1] = String(mimeType, canBeNull=True, attribName='mimeType')
        self._isNull = False

    @property
    def creationDate(self):
        return self._internal_value[Composite._fieldNumber + 2]

    @creationDate.setter
    def creationDate(self, creationDate):
        self._internal_value[Composite._fieldNumber + 2] = Time(creationDate, canBeNull=True, attribName='creationDate')
        self._isNull = False

    @property
    def modificationDate(self):
        return self._internal_value[Composite._fieldNumber + 3]

    @modificationDate.setter
    def modificationDate(self, modificationDate):
        self._internal_value[Composite._fieldNumber + 3] = Time(modificationDate, canBeNull=True, attribName='modificationDate')
        self._isNull = False

    @property
    def size(self):
        return self._internal_value[Composite._fieldNumber + 4]

    @size.setter
    def size(self, size):
        self._internal_value[Composite._fieldNumber + 4] = ULong(size, canBeNull=True, attribName='size')
        self._isNull = False

    @property
    def content(self):
        return self._internal_value[Composite._fieldNumber + 5]

    @content.setter
    def content(self, content):
        self._internal_value[Composite._fieldNumber + 5] = Blob(content, canBeNull=True, attribName='content')
        self._isNull = False

    @property
    def metaData(self):
        return self._internal_value[Composite._fieldNumber + 6]

    @metaData.setter
    def metaData(self, metaData):
        self._internal_value[Composite._fieldNumber + 6] = NamedValueList(metaData, canBeNull=True, attribName='metaData')
        self._isNull = False


class FileList(ElementList):
    shortForm = -MALShortForm.FILE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(File(v))


class ObjectIdentity(Composite):
    """The ObjectIdentity structure shall represent the Object Identity of an MO Object."""

    shortForm = MALShortForm.OBJECTIDENTITY
    _fieldNumber = Composite._fieldNumber + 3

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*3
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.domain = value[Composite._fieldNumber + 0]
            self.key = value[Composite._fieldNumber + 1]
            self.version = value[Composite._fieldNumber + 2]

    @property
    def domain(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @domain.setter
    def domain(self, domain):
        self._internal_value[Composite._fieldNumber + 0] = IdentifierList(domain, canBeNull=False, attribName='domain')
        self._isNull = False

    @property
    def key(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @key.setter
    def key(self, key):
        self._internal_value[Composite._fieldNumber + 1] = Identifier(key, canBeNull=False, attribName='key')
        self._isNull = False

    @property
    def version(self):
        return self._internal_value[Composite._fieldNumber + 2]

    @version.setter
    def version(self, version):
        self._internal_value[Composite._fieldNumber + 2] = UInteger(version, canBeNull=False, attribName='version')
        self._isNull = False


class ObjectIdentityList(ElementList):
    shortForm = -MALShortForm.OBJECTIDENTITY

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(ObjectIdentity(v))


class ServiceId(Composite):
    """The ServiceId structure shall represent a specific service in MO."""

    shortForm = MALShortForm.SERVICEID
    _fieldNumber = Composite._fieldNumber + 3

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*3
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.keyArea = value[Composite._fieldNumber + 0]
            self.keyService = value[Composite._fieldNumber + 1]
            self.keyAreaVersion = value[Composite._fieldNumber + 2]

    @property
    def keyArea(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @keyArea.setter
    def keyArea(self, keyArea):
        self._internal_value[Composite._fieldNumber + 0] = UShort(keyArea, canBeNull=False, attribName='keyArea')
        self._isNull = False

    @property
    def keyService(self):
        return self._internal_value[Composite._fieldNumber + 1]

    @keyService.setter
    def keyService(self, keyService):
        self._internal_value[Composite._fieldNumber + 1] = UShort(keyService, canBeNull=False, attribName='keyService')
        self._isNull = False

    @property
    def keyAreaVersion(self):
        return self._internal_value[Composite._fieldNumber + 2]

    @keyAreaVersion.setter
    def keyAreaVersion(self, keyAreaVersion):
        self._internal_value[Composite._fieldNumber + 2] = UOctet(keyAreaVersion, canBeNull=False, attribName='keyAreaVersion')
        self._isNull = False


class ServiceIdList(ElementList):
    shortForm = -MALShortForm.SERVICEID

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(ServiceId(v))


class NullableAttribute(Composite):
    """NullableAttribute structure shall represent an Attribute that can be nullable."""

    shortForm = MALShortForm.NULLABLEATTRIBUTE
    _fieldNumber = Composite._fieldNumber + 1

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value += [None]*1
        if value is None and self._canBeNull:
            self._isNull = True
        elif type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            self.value = value[Composite._fieldNumber + 0]

    @property
    def value(self):
        return self._internal_value[Composite._fieldNumber + 0]

    @value.setter
    def value(self, value):
        if value is None:
            self._internal_value[Composite._fieldNumber + 0] = Attribute(value, canBeNull=True, attribName='value')
        else:
            self._internal_value[Composite._fieldNumber + 0] = type(value)(value, canBeNull=True, attribName='value')
        self._isNull = False


class NullableAttributeList(ElementList):
    shortForm = -MALShortForm.NULLABLEATTRIBUTE

    def __init__(self, value=None, canBeNull=True, attribName=None):
        super().__init__(value, canBeNull, attribName)
        self._internal_value = []
        if type(value) == type(self):
            if value.internal_value is None:
                if self._canBeNull:
                    self._isNull = True
                else:
                    raise ValueError("This {} cannot be Null".format(type(self)))
            else:
                self._internal_value = value.copy().internal_value
        else:
            listvalue = value if type(value) == list else [value]
            for v in listvalue:
                 self._internal_value.append(NullableAttribute(v))


ObjectRef.value_type = ObjectIdentity  # Needed here so that ObjectIdentity is defined


class Errors(IntEnum):
    """All MAL errors."""

    Delivery_Failed = 65536  # Confirmed communication error.
    Delivery_Timedout = 65537  # Unconfirmed communication error.
    Delivery_Delayed = 65538  # Message queued somewhere awaiting contact.
    Destination_Unknown = 65539  # Destination cannot be contacted.
    Destination_Transient = 65540  # Destination middleware reports destination application does not exist.
    Destination_Lost = 65541  # Destination lost halfway through conversation.
    Authentication_Failed = 65542  # A failure to authenticate the message correctly.
    Authorisation_Fail = 65543  # A failure in the MAL to authorise the message.
    Encryption_Fail = 65544  # A failure in the MAL to encrypt/decrypt the message.
    Unsupported_Area = 65545  # The destination does not support the selected area.
    Unsupported_Area_Version = 65546  # The destination does not support the selected area version.
    Unsupported_Service = 65547  # The destination does not support the selected service.
    Unsupported_Operation = 65548  # The destination does not support the selected operation.
    Bad_Encoding = 65549  # The destination was unable to decode the message.
    Internal = 65550  # An internal error has occurred.
    Unknown = 65551  # Operation specific.
    Incorrect_State = 65552  # The destination was not in the correct state for the received message.
    Too_Many = 65553  # Maximum number of subscriptions or providers of a broker has been exceeded.
    Shutdown = 65554  # The component is being shutdown.
    Transaction_Timeout = 65555  # The interaction exceeded a certain timeout duration.
